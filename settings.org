#+TITLE: lsmag's .emacs.d
#+PROPERTY: header-args :tangle yes
#+OPTIONS: TOC:nil

TODO
configure org-capture and org-refile to automate my
braindump file thingy

* About
* Bootstrap
** Configuration management
   
Most packages listed here are installed and configured using [[https://github.com/jwiegley/use-package][use-package]]
coupled with [[https://github.com/emacsmirror/diminish][diminish]] to hide minor modes from the mode line.
   
#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
  
(require 'use-package)
(setq use-package-verbose t         ; logs to *Messages* if package takes longer than 1s to load
      use-package-always-ensure t)  ; always ensures packages are installed
      
(use-package diminish)
#+END_SRC

** Auto-updates

I set [[https://github.com/rranelli/auto-package-update.el][auto-package-update]] to auto update on startup at least once every
14 days.

#+BEGIN_SRC emacs-lisp
(use-package auto-package-update
  :init
    (setq auto-package-update-interval 14)
  :config
    (auto-package-update-maybe))
#+END_SRC

** Documenting shortcuts
   
I try to use [[https://github.com/darksmile/cheatsheet][cheatsheet]] for documenting most shortcuts defined here.
Type =M-x cheatsheet-show= to take a quick look at them.

#+BEGIN_SRC emacs-lisp
(use-package cheatsheet)
#+END_SRC

** Specific customizations
   
Sometimes emacs likes to save some specific settings. To avoid
having these appended to =.init.el=, we tell emacs to save them
on a special ignored file.

#+BEGIN_SRC emacs-lisp
(setq custom-file
      (expand-file-name
       (concat user-emacs-directory "custom.el")))
       
; The `'noerror` here is to ensure emacs doesn't break
; the custom.el does not exist
(load custom-file 'noerror)
#+END_SRC

** User-defined variables
   
Some specific variables are kept separate in a gitignored file,
all prefixed with =lsmag-=.

#+BEGIN_SRC emacs-lisp
(let ((lsmag-variables-path (expand-file-name 
                              (concat user-emacs-directory "my-variables.el"))))

  (when (file-exists-p lsmag-variables-path)
    (load-file lsmag-variables-path)))
    
(defun lsmag-get-key (variable default)
  "Evaluates variable if available or returns default"
  (if (boundp variable)
    (eval variable)
    default))
#+END_SRC

* Appearance
** Theme
   
The theme I'm using is light [[https://github.com/john2x/plan9-theme.el][plan9-theme]]. It's not "there" when I'm
editing org files but for most everything else it's good enough for
me.

#+BEGIN_SRC emacs-lisp
(use-package plan9-theme
  :config
    (load-theme 'plan9 t))
#+END_SRC

** Fonts
   
My favorite font is =Inconsolata=, you need to install it first for it
to work here.

There's also [[https://github.com/domtronn/all-the-icons.el][all-the-icons]] with a set of icons most prominently used
in Neotree. Installing the package _does not_ install the icons, for
that, please consult [[https://github.com/domtronn/all-the-icons.el#installing-fonts][their documentation]].

#+BEGIN_SRC emacs-lisp
(setq default-frame-alist '((font . "Inconsolata-14")))

(use-package all-the-icons)
#+END_SRC

** Mode line
   
I'm using [[https://github.com/Malabarba/smart-mode-line][smart-mode-line]] for beautiful and simple... mode lines (I
know, _surprise_? I'll stop with the humour). I used to use the dark
theme before but it didn't play too well with the plan9 theme.

#+BEGIN_SRC emacs-lisp
(use-package smart-mode-line
  :init
    (setq sml/no-confirm-load-theme t)  ; don't prompt to confirm before loading the theme
    (setq sml/theme 'respectful)
  :config
    (sml/setup))
#+END_SRC

** Cleaning up the UI
   
To make the editor look as clean as possible, some =bars= need to be disabled.

#+BEGIN_SRC emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
#+END_SRC

** Frame title
   
This formats the frame title with the buffer name, its mode and where it's saved.
   
#+BEGIN_SRC emacs-lisp
(setq frame-title-format '("" "%b %* [%m]"))
#+END_SRC

** Visual helpers
   
Some built-in emacs configurations involve:
- always highlight the current line
- indicate empty lines
- show line numbers

#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)  ; always highlight the current line
(global-linum-mode t)  ; shows line numbers

(setq indicate-empty-lines t)
#+END_SRC

I'm using [[https://github.com/alpaker/Fill-Column-Indicator][fill-column-indicator]] to draw a red line on column 120 to serve
as a guide too avoid too long lines.

#+BEGIN_SRC emacs-lisp
(use-package fill-column-indicator
  :diminish
  :init
    (setq fci-rule-column 120)
    (setq fci-rule-color "darkred")
  :config
    (define-globalized-minor-mode my-global-fci-mode fci-mode turn-on-fci-mode)
    (my-global-fci-mode 1))
#+END_SRC

To show vertical lines on indented blocks, [[https://github.com/zk-phi/indent-guide][indent-guide]] for the rescue!

#+BEGIN_SRC emacs-lisp
(use-package indent-guide
  :diminish
  :config
    (add-hook 'prog-mode-hook #'indent-guide-mode))
#+END_SRC

Finally, to highlight =( [ {= with different colors depending on hierarchy, I'm
using [[https://github.com/Fanael/rainbow-delimiters][rainbow-delimiters]]:

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :diminish
  :config
    (add-hook 'prog-mode-hook #'rainbow-delimiters-mode))
#+END_SRC

* General
** Evil

Hey, I like Vim's usability more than Emacs'. That's it, basically. [[https://github.com/emacs-evil/evil][Evil repo]]

#+BEGIN_SRC emacs-lisp
(use-package evil
  :config
    (evil-mode 1))
#+END_SRC

For keybindings I use [[https://github.com/noctuid/general.el][general]], since it's slightly more flexible than
other packages I used. The leader key used for shortcuts will be =SPC=.

#+BEGIN_SRC emacs-lisp
(use-package general
  :config
    (general-evil-setup))
    
(defconst lsmag-leader-key (lsmag-get-key 'lsmag-leader-prefix "SPC"))
#+END_SRC

When referring to shortcuts below - especially in inclusions for =cheatsheet=,
the function below will cut some of the 

#+BEGIN_SRC emacs-lisp
(defun lsmag-leader-shortcut/str (shortcut)
  (concat (concat lsmag-leader-key " ") shortcut))
#+END_SRC

** Ido
   
[[https://www.emacswiki.org/emacs/InteractivelyDoThings][Ido]] is an enhanced switch buffer, and comes preinstalled with Emacs 24.x.
In addition, [[https://github.com/creichert/ido-vertical-mode.el][ido-vertical-mode]] is installed as well... because vertical
list is prettier than horizontal list? idk.

#+BEGIN_SRC emacs-lisp
(setq ido-enable-flex-matching t)
(require 'ido)
(ido-mode 1)
(ido-everywhere 1)

(use-package ido-vertical-mode
  :init
    (setq ido-vertical-define-keys 'C-n-C-p-up-and-down)
    (setq ido-vertical-show-count t)
  :config
    (ido-vertical-mode 1))
#+END_SRC

Finally, [[https://github.com/DarwinAwardWinner/ido-completing-read-plus][ido-completing-read+]] is installed for replacing emacs completion
for IDO... everywhere

#+BEGIN_SRC emacs-lisp
(use-package ido-completing-read+
  :config
    (ido-ubiquitous-mode 1))
#+END_SRC

The only IDO shortcut I need the most is to switch buffers:

#+BEGIN_SRC emacs-lisp
(general-nmap :prefix lsmag-leader-key
  "sb" 'ido-switch-buffer)
  
(cheatsheet-add
  :group 'Navigation
  :key (lsmag-leader-shortcut/str "sb")
  :description "Open switch buffer menu")
#+END_SRC

** Smex
   
[[https://github.com/nonsequitur/smex][Smex]] (built on top of ido) is used here as an =M-x= replacement.

#+BEGIN_SRC emacs-lisp
(use-package smex
  :bind
    ("M-x" . smex)
    ("M-X" . smex-major-mode-commands)
    ; and this is our old M-x, should we need it
    ("C-c C-c M-x" . execute-extended-command))
    
(cheatsheet-add-group 'Smex
  '(:key "M-x" :description "Opens smex to run commands")
  '(:key "M-X" :description "Open major mode commands list")
  '(:key "C-c C-c M-x" :description "Opens good ol' M-x instead of smex"))
#+END_SRC

** Which-key
   
The package [[https://github.com/justbur/emacs-which-key][which-key]] will show possible keybindings for your currently entered incomplete command.

#+BEGIN_SRC emacs-lisp
(use-package which-key
  :diminish
  :init
    (setq which-key-idle-delay 0.5)
  :config
    (which-key-mode))
#+END_SRC

** Eldoc
   
[[https://www.emacswiki.org/emacs/ElDoc][Eldoc]] is a minor mode that shows the argument list of the function call in the echo area.
Simple, but handy.

#+BEGIN_SRC emacs-lisp
(add-hook 'prog-mode-hook 'turn-on-eldoc-mode)
#+END_SRC

** Projectile
   
Used ostensibly for package management.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :config
    (projectile-global-mode))
    
(general-nmap :prefix lsmag-leader-key
  "pf" 'projectile-find-file)
  
(cheatsheet-add
  :group 'Navigation
  :key (lsmag-leader-shortcut/str "pf")
  :description "Open projectile menu to find files within a project")
#+END_SRC

** Switching workspaces

Kinda like virtual desktops, [[https://github.com/wasamasa/eyebrowse][https://github.com/wasamasa/eyebrowse]] allows me to maintain
multiple workspaces with independent frames.

#+BEGIN_SRC emacs-lisp
(use-package eyebrowse
  :init
    ; =t= here means eyebrowse will always open a new workspace clean with *Scratch*
    (setq eyebrowse-new-workspace t)
  :config
    (eyebrowse-mode))
    
(general-nmap :prefix lsmag-leader-key
  "1" 'eyebrowse-switch-to-window-config-1
  "2" 'eyebrowse-switch-to-window-config-2
  "3" 'eyebrowse-switch-to-window-config-3
  "4" 'eyebrowse-switch-to-window-config-4
  "5" 'eyebrowse-switch-to-window-config-5
  "6" 'eyebrowse-switch-to-window-config-6
  "7" 'eyebrowse-switch-to-window-config-7
  "8" 'eyebrowse-switch-to-window-config-8
  "9" 'eyebrowse-switch-to-window-config-9
  "0" 'eyebrowse-switch-to-window-config-0
  "ww" 'eyebrowse-switch-to-last-window-config
  "wc" 'eyebrowse-close-window-config)
  
(cheatsheet-add-group 'Navigation
  `(:key ,(lsmag-leader-shortcut/str "<number>") :description "Switch to workspace")
  `(:key ,(lsmag-leader-shortcut/str "ww") :description "Switch to last used workspace")
  `(:key ,(lsmag-leader-shortcut/str "wc") :description "Close current workspace"))
#+END_SRC

** File explorer
   
[[https://github.com/jaypei/emacs-neotree][Neotree]] opens a handy file explorer in a sidebar.. because sometimes we're not
in a project and that comes in handy, y'know?

#+BEGIN_SRC emacs-lisp
(use-package neotree
  :init
    (setq neo-theme 'icons))

(general-nmap :prefix lsmag-leader-key "pt" 'neotree-toggle)

(cheatsheet-add
  :group 'Navigation
  :key (lsmag-leader-shortcut/str "pt")
  :description "Toggle the NEOTree file explorer")
#+END_SRC

** Frame navigation
   
When navigating through two windows, =C-w C-w= (default from Evil) is great.  For more
than that, [[https://github.com/abo-abo/ace-window][ace-window]] is a likely better.
   
#+BEGIN_SRC emacs-lisp
(use-package ace-window
  :bind
    ("M-o" . ace-window))
    
(cheatsheet-add
  :group 'Navigation
  :key "M-o"
  :description "Navigate windows using ace-window")
#+END_SRC

** Code folding
   
[[https://github.com/gregsexton/origami.el][Origami]] is a more decent code-folding mode for Emacs.

#+BEGIN_SRC emacs-lisp
(use-package origami
  :diminish
  :config
    (global-origami-mode))
    
(general-nmap :prefix lsmag-leader-key
  "ff" 'origami-toggle-node
  "fo" 'origami-open-node
  "fc" 'origami-close-node
  "fro" 'origami-open-node-recursively
  "frc" 'origami-close-node-recursively)
  
(cheatsheet-add-group 'Folding
  `(:key ,(lsmag-leader-shortcut/str "ff") :description "Toggle folding")
  `(:key ,(lsmag-leader-shortcut/str "fo") :description "Opens a block")
  `(:key ,(lsmag-leader-shortcut/str "fc") :description "Closes a block")
  `(:key ,(lsmag-leader-shortcut/str "fro") :description "Recursively opens a block")
  `(:key ,(lsmag-leader-shortcut/str "frc") :description "Recursively closes a block"))
#+END_SRC

** Finding definitions in a file
   
[[https://github.com/bmag/imenu-list][imenu-list]] creates a buffer containing the current buffer's [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Imenu.html][imenu]]
entries.  Useful for finding definitions in a file.

#+BEGIN_SRC emacs-lisp
(use-package imenu-list
  :diminish)
  
(general-nmap :prefix lsmag-leader-key
  "pa" 'imenu-list-smart-toggle)
  
; Yes, I am repeating the same function with a different binding here,
; and I don't remember why I did that :(
(general-nmap
  "C-'" 'imenu-list-smart-toggle)
  
(cheatsheet-add
  :group 'Navigation
  :key (lsmag-leader-shortcut/str "pa")
  :description "Toggle imenu with up-to-date file's tags")
#+END_SRC

** Spell checker
   
=Aspell= is my preferred spell checker. If not available, emacs will
check for =hunspell= instead.

I also set the spell checker to check comments and strings on prog
modes (when editing programming language files) and on Org files.
   
#+BEGIN_SRC emacs-lisp
(cond
  ((executable-find "aspell")
    (setq ispell-program-name "aspell"))

  ((executable-find "hunspell")
    (setq ispell-program-name "hunspell"))

  (t
    (setq ispell-program-name nil)))
    
(add-hook 'prog-mode-hook #'flyspell-prog-mode)
(add-hook 'org-mode-hook #'flypell-mode)
#+END_SRC

** Syntax checker
   
Easy enough, [[http://www.flycheck.org/en/latest/][flycheck]] is used globally. I've also added
[[https://github.com/flycheck/flycheck-pos-tip][flycheck-pos-tip]] for sweet syntax check pop-ups.
   
#+BEGIN_SRC emacs-lisp
(use-package flycheck
  :config
    (global-flycheck-mode))
    
(use-package flycheck-pos-tip
  :diminish
  :config
    (with-eval-after-load 'flycheck
      (flycheck-pos-tip-mode)))
#+END_SRC

** Text completion
   
[[https://company-mode.github.io/][Company]] is the main framework here. A few other specialized packages
will be installed when needed, depending on
language. [[https://github.com/expez/company-quickhelp][company-quickhelp]] extends company by adding completion
pop-ups.

#+BEGIN_SRC emacs-lisp
(use-package company)

(use-package company-quickhelp
  :config
    (company-quickhelp-mode))
#+END_SRC

* Applications
** TODO Elfeed
** TODO Ranger
** TODO Magit
* Programming
** Python
   
Packages: [[https://github.com/proofit404/anaconda-mode][Anaconda-mode]] and [[https://github.com/proofit404/company-anaconda][company-anaconda]]

#+BEGIN_SRC emacs-lisp
(use-package anaconda-mode
  :config
    (add-hook 'python-mode-hook 'anaconda-mode)
    (add-hook 'python-mode-hook 'anaconda-eldoc-mode))

(use-package company-anaconda
  :config
    (with-eval-after-load 'company
      (add-to-list 'company-backends 'company-anaconda)))
#+END_SRC

** Javascript
   
Packages: [[https://github.com/mooz/js2-mode][js2-mode]] and [[https://github.com/proofit404/company-tern][company-tern]]

#+BEGIN_SRC emacs-lisp
(use-package js2-mode
  :config
    (setq js-indent-level 2))

(use-package company-tern
  :config
    (with-eval-after-load 'company
      (add-to-list 'company-backends 'company-tern)))
#+END_SRC
   
** Front-end
   
Packages: [[http://web-mode.org/][web-mode]] and [[https://github.com/AdamNiederer/vue-mode][vue-mode]]
   
#+BEGIN_SRC emacs-lisp
(use-package web-mode
  :config
    (require 'web-mode)
    (add-to-list 'auto-mode-alist '("\\.phtml\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.tpl\\.php\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.[agj]sp\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.as[cp]x\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.erb\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.mustache\\'" . web-mode))
    (add-to-list 'auto-mode-alist '("\\.djhtml\\'" . web-mode)))

(use-package vue-mode)
#+END_SRC

** Elixir
   
Packages: [[https://github.com/elixir-editors/emacs-elixir][elixir-mode]] an [[https://github.com/tonini/alchemist.el][alchemist]]

#+BEGIN_SRC emacs-lisp
(use-package elixir-mode)
(use-package alchemist)
#+END_SRC

** Markdown
   
Package: [[https://jblevins.org/projects/markdown-mode/][markdown-mode]]
   
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode
  :commands (markdown-mode gfm-mode)
  :mode (("README\\.md\\'" . gfm-mode)
         ("\\.md\\'" . markdown-mode)
         ("\\.markdown\\'" . markdown-mode))
  :init (setq markdown-command "multimarkdown"))
#+END_SRC

* Org
  
TODO
add body

#+BEGIN_SRC emacs-lisp
(require 'org)
(setq org-capture-templates
  '(("t"
     "Todo"
     entry
     (file+headline "~/codex/braindump.org" "Soon")
     "* TODO %? %^g"
     :prepend t)))
     
(add-hook 'org-mode-hook #'flyspell-mode)
#+END_SRC

* Custom functions
** Splitting windows
   
Evil's default behavior on splitting doesn't focus on the new window
when created. These functions fix this:

#+BEGIN_SRC emacs-lisp
(defun lsmag-do-split ()
  "Splits horizontally and focuses on the new window"
  (interactive)
  (evil-window-split)
  (evil-window-down 1))
  
(defun lsmag-do-vsplit ()
  "Splits vertically and focuses on the new window"
  (interactive)
  (evil-window-vsplit)
  (evil-window-right 1))
  
(general-nmap :prefix lsmag-leader-key
  "vv" 'lsmag-do-vsplit
  "ss" 'lsmag-do-split)  
  
(cheatsheet-add-group 'Splitting
  `(:key ,(lsmag-leader-shortcut/str "vv") :description "Split windows vertically")
  `(:key ,(lsmag-leader-shortcut/str "ss") :description "Split windows horizontally"))
#+END_SRC
